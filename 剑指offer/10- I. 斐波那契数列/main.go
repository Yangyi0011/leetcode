package main

/*
============== 剑指 Offer 10- I. 斐波那契数列 ==============
写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：
	F(0) = 0,   F(1) = 1
	F(N) = F(N - 1) + F(N - 2), 其中 N > 1.

斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

示例 1：
输入：n = 2
输出：1

示例 2：
输入：n = 5
输出：5

提示：
    0 <= n <= 100

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof
*/
/*
	方法一：递归
	思路：
		把 f(n) 问题的计算拆分成 f(n−1) 和 f(n−2) 两个子问题的计算，并递归，
		以 f(0) 和 f(1) 为终止条件。

		注：递归会涉及到大量的重复计算，例如 f(n) 和 f(n−1) 两者向下递归需
			要各自计算 f(n−2) 的值。
	时间复杂度：O(2^n)
		对于 f(n) 和 f(n−1)，我们都需要重复计算 f(n-2)，随着 n 的增大，复杂
		度会呈 n 的指数级上升。
	空间复杂度：O(n)
		递归计算需要消耗 O(n) 的额外栈空间。
*/
func fib(n int) int {
	if n == 0 {
		return 0
	}
	if n == 1 {
		return 1
	}
	return (fib(n-1) + fib(n-2)) % 1000000007
}

/*
	方法二：
	思路：
		从方法一可知，递归计算是“自顶向下”的运算过程，该过程中会涉及到很多重复
		计算，而我们已经知道了递归的终止条件，那么我们就可以以此为起始条件，
		通过循环的方式“自底向上”完成递归的逆运算过程，在循环过程中我们会记录下
		每一步的计算结果，后序再遇到该步的计算则可以直接使用，如此可以避免重复
		计算。
	时间复杂度：O(n)
		在循环过程中，我们可以直接从 2 计算到 n，中间涉及到需要重复计算的地方，
		我们都直接从已保存好的计算结果列表中提取，不再需要重复计算。
	空间复杂度：O(n)
		我们需要存储 0~n 的所有斐波那契数列计算结果。
*/
func fib2(n int) int {
	if n == 0 {
		return 0
	}
	if n == 1 {
		return 1
	}
	ans := make([]int, n+1)
	ans[0] = 0
	ans[1] = 1
	for i := 2; i <= n; i++ {
		ans[i] = (ans[i-1] + ans[i-2]) % 1000000007
	}
	return ans[n]
}

/*
	方法三：动态规划【循环空间优化】
	思路：
		状态定义：设 dp 为一维数组，其中 dp[i] 的值代表斐波那契数列第 i 个
				数字 。
		起始条件：
			dp[0] = 0, dp[1] = 1
		状态转移方程：
			dp[i] = dp[i-1] + dp[i-2]，即 f(n) = f(n-1) + f(n-2)
		终止条件：
			dp(n)
	空间优化：
		在方法二的循环处理过程中，我们需要记录每一步运算的结果来避免重复运算，
		但通过观察斐波那契数列的状态转移方程 dp[i] = dp[i-1] + dp[i-2] 发现，
		对于每一个状态 dp[i] 来说，能够影响其状态变化的只有 dp[i-1] 和
		dp[i-2]，我们无需额外记录 dp[0] ~ dp[i-3] 的中间状态值。
		如此我们只需用两个变量来记录 dp[i-1] 和 dp[i-2] 就能完成所有斐波那
		契数的状态转移计算。
	循环求余法：
		大数越界：
			随着 n 增大, f(n) 会超过 Int32 甚至 Int64 的取值范围，导致最终
			的返回值错误。
		求余运算规则：
			设正整数 x、y、p，求余符号为 ⊙，则有 (x+y)⊙p=(x⊙p+y⊙p)⊙p
		解析：
			根据以上规则，可推出 f(n)⊙p=[f(n−1)⊙p+f(n−2)⊙p]⊙p ，
			从而可以在循环过程中每次计算 sum=(a+b)⊙1000000007，此操作
			与最终返回前取余等价。
	时间复杂度：O(n)
	空间复杂度：O(1)
*/
func fib3(n int) int {
	if n == 0 {
		return 0
	}
	if n == 1 {
		return 1
	}
	a, b := 0, 1
	ans := 0
	for i := 2; i <= n; i++ {
		ans = (a + b) % 1000000007
		a = b
		b = ans
	}
	return ans
}
