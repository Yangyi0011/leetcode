package main

import (
	"fmt"
	"math"
)

/*
============== 剑指 Offer 14- I. 剪绳子 ==============
给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，
n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问
k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，
我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

示例 1：
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1

示例 2:
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36

提示：
    2 <= n <= 58

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/jian-sheng-zi-lcof
*/
/*
	方法一：动态规划【DP】
	思路：
		在剪绳子的过程中，每一步我们都有剪和不剪两种选择。
		假设当前绳子长度为 n，如果我们不剪，那么此时乘积为 n，如果
		我们从 i (i∈[1, n]) 的位置剪下，则绳子变成长度为 i 和 n-i
		两段，此时乘积为 i*(n-i) ，但这时候我们不知道 n 和 i*(n-i) 是不是
		最大乘积，所以我们需要对 i 段和 n-i 段进行尝试剪切，以求他们的
		最大乘积。
		我们设长度为 n 的绳子剪成若干段后这些段的长度的最大乘积为 f(n)，
		则根据上面分析可知，f(n) = max(f(n), f(i)*f(n-i))

		这是一个自顶向下的递推公式，由于递推过程中会涉及到很多重复的子问题
		计算，因此我们需要转换一下思路，改为自底向上来处理该问题。

		动态规划：
			定义：
				我们定义 dp[i] 为长度为 i 的绳子剪成若干段后得到的乘积的最
				大值。
			初始条件：
				当绳子的长度为 0 或 1 时，因为题目要求必须被切为两段以上，
					且每段长度都为整数，所以此时无解，即 dp[0] = dp[1] = 0。
				当绳子的长度为 2 时，此时只有一种剪法，即剪为长度为 1 的两段，
					此时 dp[2] = 1 * 1 = 1
				所以初始条件为：
					dp[0] = 0，绳子长度为 0 时
					dp[1] = 0，绳子长度为 1 时
					dp[2] = 1，绳子长度为 2 时
			状态转移方程：
				假设第一刀下刀的位置为 i，想要在 i 长度之下继续剪切获得最大乘积，
				则可以考虑在 j (j∈[1,i))位置剪第二刀，此时的最大乘积为：
					dp[i] = max(dp[i], dp[j] * dp[i-j])
			终止条件：
				dp[n]
	时间复杂度：O(n^2)
	空间复杂度：O(1)
*/
func cuttingRope(n int) int {
	dp := make([]int, n+1)
	dp[0], dp[1], dp[2] = 0, 0, 1
	// i 为第一刀剪下的长度
	for i := 3; i <= n; i++ {
		// j 为在 i 的基础上继续剪切获得的长度
		for j := 1; j < i; j++ {
			// 这一刀剪下后得的乘积
			product := j * (i - j)
			// 对剩下长度继续剪的最大乘积，取最大乘积
			// 因为我们是自底向上递推的，dp[i-j] 必然已经被提前求出
			product = max(product, j * dp[i-j])
			// 取最大乘积
			dp[i] = max(dp[i], product)
		}
	}
	return dp[n]
}
func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

/* 
	方法二：贪心算法
	思路：
		设一绳子长度为 n ( n>1 )，则其必可被切分为两段 n=n1+n2​ 。
		根据经验推测，切分的两数字乘积往往比原数字更大，即往往有 n1×n2>n1+n2=n。
			例如绳子长度为 6 ： 6=3+3<3×3=9；
			也有少数反例，例如 2： 2=1+1>1×1=1。
		推论一： 合理的切分方案可以带来更大的乘积。

		设一绳子长度为 n ( n>1 )，切分为两段 n=n1+n2​ ，切分为三段 n=n1+n2+n3。
		根据经验推测，三段 的乘积往往更大，即往往有 n1n2n3>n1n2。
			例如绳子长度为 9： 两段 9=4+5和 三段 9=3+3+3，则有 4×5<3×3×3。
			也有少数反例，例如 6 ： 两段 6=3+3 和 三段 6=2+2+2，则有 3×3>2×2×2。
		推论二： 若切分方案合理，绳子段切分的越多，乘积越大。

		总体上看，貌似长绳子切分为越多段乘积越大，但其实到某个长度分界点后，乘积到达最大值，就不应再切分了。
		问题转化： 是否有优先级最高的长度 x 存在？若有，则应该尽可能把绳子以 x 长度切为多段，以获取最大乘积。

		推论三： 为使乘积最大，只有长度为 2 和 3 的绳子不应再切分，且 3 比 2 更优 （详情见下表） 。
			绳子切分方案 	乘积 				结论
			2=1+1 		   1×1=1				2 不应切分
			3=1+2		   1×2=2 				3 不应切分
			4=2+2=1+3 	   2×2=4>1×3=3 			4 和 2 等价，且 2+2 比 1+3 更优
			5=2+3=1+4 	   2×3=6>1×4=4 		 	5 应切分为 2+3
			6=3+3=2+2+2	   3×3=9>2×2×2=8		6 应切分为 3+3 ，进而推出 3 比 2 更优
			>7			 	... 				长绳（长度>7）可转化为多个短绳（长度1~6），因此肯定应切分
	时间复杂度：O(1)
	空间复杂度：O(1)
*/
func cuttingRope2(n int) int {
	if n <= 3 {
		return n-1
	}
	a, b := n / 3, n % 3
	if b == 0 {
		return int(math.Pow(3, float64(a)))
	}
	// 最后余数为 1 时，可以看做 3+1 = 4，4 不用分
	if b == 1 {
		return int(math.Pow(3, float64(a - 1)) * 4)
	}
	// 最后余数为 2 时，直接乘入结果
	return int(math.Pow(3, float64(a))) * 2
}


func main() {
	// res := cuttingRope(10)
	res := cuttingRope2(10)
	fmt.Println(res)
}
