package main

import "fmt"

/*
============== 剑指 Offer 50. 第一个只出现一次的字符 ==============
在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包
含小写字母。

示例:
s = "abaccdeff"
返回 "b"

s = ""
返回 " "

限制：
0 <= s 的长度 <= 50000

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof
*/
/*
	方法一：哈希表法
	思路：
		遍历数组，把每一个字符的出现次数记录在哈希表中。
		但题目要求返回第一个只出现一次的字符，而哈希表是无序的，所以我们还
		需要额外记录每一位字符第一次出现时的下标，故我们的哈希表结构如下：
			key：字符
			value：{firstIdex, count}
		最后我们再遍历整个哈希表，寻找出现次数为1，且下标最小的那个字符进行
		返回。
	时间复杂度：O(n)
		n 是字符串的长度，我们需要遍历字符串，记录每一个字符第一次出现的下
		标和出现的次数，耗时O(n)，最后我们还需要遍历哈希表，找出出现次数为 1，
		且下标最小的那个字符进行返回，耗时O(k)，k 是字符集的字符数，因为字符串
		只包含小写字母，所以 k=26，故总的线性时间复杂度为O(n)。
	空间复杂度：O(k)
		k 是字符集的字符数，因为字符串只包含小写字母，所以 k=26，我们需要
		用哈希表记录每一个字符出现的次数和第一次出现的下标。
*/
func firstUniqChar(s string) byte {
	n := len(s)
	if n == 0 {
		return ' '
	}
	hash := make(map[byte][2]int, 0)
	for i := 0; i < n; i++ {
		if v, ok := hash[s[i]]; ok {
			// 非第一次出现，只让出现次数 +1
			v[1]++
			hash[s[i]] = v
		} else {
			// 第一次出现，记录出现下标和出现次数
			hash[s[i]] = [2]int{i, 1}
		}
	}
	// 记录最小下标
	minIndex := n
	// 寻找第一个只出现一次的字符
	for _, v := range hash {
		if v[1] == 1 {
			if v[0] < minIndex {
				minIndex = v[0]
			}
		}
	}
	// 找不到
	if minIndex == n {
		return ' '
	}
	return s[minIndex]
}

/*
	方法二：数组
	思路：
		上面使用哈希表时，我们需要额外记录每个字符第一次出现的下标，且因为
		哈希表是无序的，最后我们需要遍历完整个哈希表才能找到结果，这就需要
		消耗额外的空间和时间。
		对于涉及到下标和顺序这种问题，显然用数组来处理是更合适的，我们知道
		字符集是有限的，所以完全不用担心一个数组装不下的问题，故我们可以这
		样做：
			建立一个长度为 26 的数组，使用每一个字符 - 'a' 来作为该字符在
			数组中的下标，而数组值即为该字符出现的次数，如此我们便得到了一
			个简易的哈希表，key：字符 - 'a'，value：出现次数。
			最后我们在寻找第一个只出现一次的字符时，我们只需要按顺序遍历 s，
			找到第一个 arr[s[i] - 'a'] = 1 的字符进行返回即可。
	时间复杂度：O(n)
		n 是字符串长度，我们需要遍历字符串记录每一个字符出现的次数，耗时O(n)，
		最后再遍历 s 找到第一个出现次数为 1 的字符进行返回，耗时O(n)，
		故总的线性时间复杂度为 O(n)。
	空间复杂度：O(k)
		k 是字符集的字符数，因为字符串只包含小写字母，所以 k=26，我们需要
		用数组记录每一个字符出现的次数。
*/
func firstUniqChar2(s string) byte {
	n := len(s)
	if n == 0 {
		return ' '
	}
	arr := [26]int{}
	for i := 0; i < n; i++ {
		arr[s[i]-'a']++
	}
	for i := 0; i < n; i++ {
		if arr[s[i]-'a'] == 1 {
			return s[i]
		}
	}
	return ' '
}

func main() {
	s := "leetcode"
	res := firstUniqChar2(s)
	fmt.Printf("%c\n", res)
}
